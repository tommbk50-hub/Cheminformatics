# -*- coding: utf-8 -*-
"""GCMS_simulator._colab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XQ6eKQMhtnt5VIhyMNIXRL87j-pFXIi2

# Mass Spectrometry Fragmentation Tree and Simulated GCMS Spectrum from SMILES
"""

# @title Install (Colab-safe) - Run this cell twice!
import sys, subprocess, os, importlib

def pipi(*args):
    """Helper function to run quiet pip installs."""
    print("pip install", " ".join(args))
    # Using check_call will raise an error if installation fails
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", *args])

# 0) Keep toolchain current for best compatibility
pipi("--upgrade", "pip", "setuptools", "wheel")

# 1) Handle NumPy compatibility for RDKit
# RDKit often requires NumPy < 2.0. We check, downgrade if needed, and force a restart.
need_restart = False
try:
    # Try to import NumPy and check its version
    import numpy as _np
    major = int(_np.__version__.split(".")[0])
    if major >= 2:
        print("Found NumPy >= 2.0. Downgrading to <2.0 for RDKit compatibility.")
        pipi("numpy<2.0")
        need_restart = True
except (ImportError, Exception):
    # If NumPy is not found or check fails, install the compatible version.
    print("NumPy not detected or check failed. Installing NumPy < 2.0.")
    pipi("numpy<2.0")
    need_restart = True

if need_restart:
    print("\n\n####################################################################")
    print("✅ Successfully adjusted NumPy version.")
    print("⚠️  The Colab runtime must restart to apply this change for stability.")
    print("   Please **re-run this cell** *after* the runtime has automatically restarted.")
    print("####################################################################\n\n")
    # Force Colab runtime restart (this is the key to reliability)
    os.kill(os.getpid(), 9)

# 2) Install all other required packages (this only runs after the restart)
print("\nInstalling RDKit and other dependencies...")
# Install: mpld3, adjustText (from your original code), and pillow
pipi("mpld3>=0.5.9", "adjustText>=1.0.4", "pillow")

# Install RDKit: try standard wheel
try:
    pipi("rdkit")
    # Try the rdkit-pypi version as an additional stable option if the above fails
except subprocess.CalledProcessError:
    print("⚠️  'rdkit' standard install failed. Trying 'rdkit-pypi' fallback…")
    pipi("rdkit-pypi>=2023.9.5")

print("\nAll installations complete. Run the rest of your notebook!")

#@title Mass Spectrometry Fragmentation Tree:
#imports
from rdkit import Chem
from rdkit.Chem import Recap, Descriptors
from rdkit.Chem.Draw import rdMolDraw2D
from IPython.display import display, SVG, HTML
import ipywidgets as w, itertools, re

#helpers
def _smiles2mol(smi, add_hs=False):
    m = Chem.MolFromSmiles(smi)
    return Chem.AddHs(m) if add_hs else m

def _ion_mass(mol, protonate=True):
    return Descriptors.ExactMolWt(mol) + 1.007276, 1  # simple [M+H]+

#recap fragmentation
def _recap_levels(mol):
    root   = Recap.RecapDecompose(mol)
    roots  = [root] if root.smiles else list(root.children.values())
    levels = []
    def walk(node, d=0):
        if len(levels) <= d:
            levels.append([])
        levels[d].append(node.smiles)
        for ch in node.children.values():
            walk(ch, d+1)
    for n in roots: walk(n, 0)
    return levels

#MS-style fragmentation
def _cleavable_bonds(mol):
    hetero = lambda a: a.GetAtomicNum() not in (1, 6)
    cleav  = set()
    for bond in mol.GetBonds():
        if bond.GetBondType() != Chem.BondType.SINGLE:   continue
        i, j = bond.GetBeginAtom(), bond.GetEndAtom()
        if hetero(i) or hetero(j):                    # hetero‑adjacent
            cleav.add(bond.GetIdx()); continue
        alpha = lambda at: any(hetero(n) for n in at.GetNeighbors())
        if alpha(i) or alpha(j):                      # α‑cleavage
            cleav.add(bond.GetIdx()); continue
        if bond.IsInRing():                           # ring‑opening
            cleav.add(bond.GetIdx())
    return list(cleav)

def _ms_levels(mol, *, max_depth=3, min_heavy=2):
    levels, frontier = [[Chem.MolToSmiles(mol)]], [mol]
    seen = set(levels[0])
    for _ in range(max_depth):
        nxt = []
        for m in frontier:
            for b in _cleavable_bonds(m):
                frag  = Chem.FragmentOnBonds(m, [b], addDummies=False)
                parts = Chem.GetMolFrags(frag, asMols=True, sanitizeFrags=True)
                for p in parts:
                    if p.GetNumHeavyAtoms() < min_heavy:   continue
                    smi = Chem.MolToSmiles(p)
                    if smi not in seen:
                        seen.add(smi); nxt.append(p)
        if not nxt: break
        levels.append([Chem.MolToSmiles(x) for x in nxt])
        frontier = nxt
    return levels

#draw tree
def draw_frag_tree(smiles, *, digits=2, cell=(260,260),
                   levels_fn=_recap_levels):
    parent  = _smiles2mol(smiles)
    levels  = levels_fn(parent)

    n_cols  = max(len(row) for row in levels)
    mols, legs = [], []
    for smi in itertools.chain.from_iterable(levels):
        m   = _smiles2mol(smi)
        mz,_= _ion_mass(m)
        mols.append(m)
        legs.append(f"m/z={mz:.{digits}f}")

    pad = n_cols * len(levels) - len(mols)
    mols.extend([Chem.Mol()] * pad)
    legs.extend([""] * pad)

    w_cell, h_cell = cell
    drawer = rdMolDraw2D.MolDraw2DSVG(
        n_cols*w_cell, (len(mols)//n_cols)*h_cell, w_cell, h_cell)
    drawer.drawOptions().legendFontSize = 18
    drawer.DrawMolecules(tuple(mols), legends=tuple(legs))
    drawer.FinishDrawing()
    svg = drawer.GetDrawingText()

    # inject white background rect directly into the SVG
    svg = re.sub(r'<svg[^>]*>',
                 lambda m: m.group(0) +
                 '<rect width="100%" height="100%" fill="white"/>',
                 svg, count=1)
    svg = svg.replace('<?xml version="1.0" encoding="UTF-8"?>', '')
    return SVG(svg)

#UI widgets
smi_box  = w.Text(value=' OC[C@H]1[C@H](C2=CC(F)=CC=C2)CN(C3=CC(C)=NC=C3C#N)C1',
                  description='SMILES:',
                  layout=w.Layout(width='65%'))
mode_box = w.Dropdown(
    options={'Retrosynthetic (RECAP)': _recap_levels,
             'MS‑like (hetero/α/ring)': _ms_levels},
    value=_ms_levels, description='Mode:')
btn  = w.Button(description='Generate tree', button_style='success')
out  = w.Output()

def _run(_):
    out.clear_output()
    with out:
        try: display(draw_frag_tree(smi_box.value, digits=4,
                                    levels_fn=mode_box.value))
        except Exception as e:
            print('⚠️', e)

btn.on_click(_run)

# global CSS tweak – white output pane
display(HTML("""
<style>
  .widget-output, .output_svg {background:white !important;}
</style>
"""))

display(w.VBox([w.HBox([smi_box, mode_box]), btn, out]))

# @title Simulated GCMS Spectrum
SMILES = "OC[C@H]1[C@H](C2=CC(F)=CC=C2)CN(C3=CC(C)=NC=C3C#N)C1"  # @param {type:"string"}
ION_MODE = "ESI+"  # @param ["ESI+","ESI-","EI"]
TOLERANCE_PPM = 15  # @param {type:"number"}
LABEL_MODE = "ion+mz"  # @param ["ion+mz","ion","mz"]
PRESET = "presentation"  # @param ["publication","crowded","lightweight","presentation","parent_focus"]

# ---- visibility & scaling knobs ------------------------------------------------
FRAG_GROUP_MAX    = 100.0   # max a.u. for fragment group before final normalisation
ADDUCT_GROUP_MAX  = 80.0    # max a.u. for molecular-adduct group before final normalisation
INTENSITY_GAMMA   = 0.65    # 0.5–0.8 lifts small peaks; 1.0 = no compression
MIN_VISIBLE_INT   = 2.0     # minimum visible peak height (% RI)

# ---- label layout: stronger anti-overlap --------------------------------------
STICK_CLEAR_DX    = 1.10    # min x-distance from ANY stick when placing a label (m/z units)
TEXT_CLEAR_DX     = 0.55    # min x-distance between two placed labels (m/z units)

# ---- FIXED colour normalisation for adduct probabilities (percent) ------------
PROB_COLOR_MIN = 0.0
PROB_COLOR_MAX = 65.0       # [M+H]+ ≈ 62.6% in NIST12
COLOR_MAP_NAME  = "RdYlBu_r"  # red → blue
SHOW_COLORBAR   = True
SHOW_ADDUCT_LIST = True
ADDUCT_LEGEND_MAX = 12

# ── quiet installs (Colab-safe)
import sys, subprocess, importlib
def _pip(*pkgs): subprocess.check_call([sys.executable,"-m","pip","install","-q",*pkgs])
for pkg in ("rdkit-pypi","Pillow","adjustText","mpld3"):
    try: importlib.import_module(pkg.split("-")[0])
    except Exception:
        try: _pip(pkg)
        except Exception: pass

import io, numpy as np, matplotlib as mpl, matplotlib.pyplot as plt, mpld3
from matplotlib import cm
from mpld3 import plugins
from rdkit import Chem
from rdkit.Chem import Draw, rdMolDescriptors as rdMD
from rdkit.Chem.rdMolDescriptors import CalcMolFormula
from adjustText import adjust_text
from IPython.display import HTML, display

# ── presets
PRESETS = {
    "publication": dict(
        FIG_W_IN=18.0, FIG_H_IN=6.5, FIG_DPI=160,
        SAMPLES_PER_STICK=28,
        LABEL_FONTSIZE=12, AXIS_LABEL_FONTSIZE=13, TITLE_FONTSIZE=16,
        TICK_FONTSIZE=12, TOOLTIP_CAPTION_PX=14,
        MIN_INT_FOR_LABEL=5, MAX_LABELS=80,
        MIN_MZ_GAP=1.00, PREFER_PARENT=True,
        MIN_LABEL_X_SEP=0.50, X_DODGE_STEP=0.22, MAX_DODGE_STEPS=5,
        LABEL_LANES=6, LABEL_Y_OFFSET_FRAC=0.070, CONNECTORS=True, MAX_ION_CHARS=22
    ),
    "crowded": dict(
        FIG_W_IN=22.0, FIG_H_IN=8.0, FIG_DPI=160,
        SAMPLES_PER_STICK=30,
        LABEL_FONTSIZE=12, AXIS_LABEL_FONTSIZE=13, TITLE_FONTSIZE=16,
        TICK_FONTSIZE=12, TOOLTIP_CAPTION_PX=14,
        MIN_INT_FOR_LABEL=5, MAX_LABELS=110,
        MIN_MZ_GAP=1.25, PREFER_PARENT=True,
        MIN_LABEL_X_SEP=0.60, X_DODGE_STEP=0.24, MAX_DODGE_STEPS=7,
        LABEL_LANES=7, LABEL_Y_OFFSET_FRAC=0.080, CONNECTORS=True, MAX_ION_CHARS=20
    ),
    "lightweight": dict(
        FIG_W_IN=16.0, FIG_H_IN=6.0, FIG_DPI=120,
        SAMPLES_PER_STICK=18,
        LABEL_FONTSIZE=11, AXIS_LABEL_FONTSIZE=12, TITLE_FONTSIZE=15,
        TICK_FONTSIZE=11, TOOLTIP_CAPTION_PX=12,
        MIN_INT_FOR_LABEL=7, MAX_LABELS=50,
        MIN_MZ_GAP=1.20, PREFER_PARENT=True,
        MIN_LABEL_X_SEP=0.60, X_DODGE_STEP=0.22, MAX_DODGE_STEPS=5,
        LABEL_LANES=5, LABEL_Y_OFFSET_FRAC=0.070, CONNECTORS=False, MAX_ION_CHARS=18
    ),
    "presentation": dict(
        FIG_W_IN=24.0, FIG_H_IN=9.0, FIG_DPI=150,
        SAMPLES_PER_STICK=30,
        LABEL_FONTSIZE=14, AXIS_LABEL_FONTSIZE=16, TITLE_FONTSIZE=20,
        TICK_FONTSIZE=14, TOOLTIP_CAPTION_PX=16,
        MIN_INT_FOR_LABEL=5, MAX_LABELS=100,
        MIN_MZ_GAP=1.00, PREFER_PARENT=True,
        MIN_LABEL_X_SEP=0.55, X_DODGE_STEP=0.24, MAX_DODGE_STEPS=7,
        LABEL_LANES=7, LABEL_Y_OFFSET_FRAC=0.085, CONNECTORS=True, MAX_ION_CHARS=24
    ),
    "parent_focus": dict(
        FIG_W_IN=18.0, FIG_H_IN=6.5, FIG_DPI=150,
        SAMPLES_PER_STICK=26,
        LABEL_FONTSIZE=12, AXIS_LABEL_FONTSIZE=13, TITLE_FONTSIZE=16,
        TICK_FONTSIZE=12, TOOLTIP_CAPTION_PX=14,
        MIN_INT_FOR_LABEL=6, MAX_LABELS=60,
        MIN_MZ_GAP=1.20, PREFER_PARENT=True,
        MIN_LABEL_X_SEP=0.60, X_DODGE_STEP=0.24, MAX_DODGE_STEPS=6,
        LABEL_LANES=6, LABEL_Y_OFFSET_FRAC=0.080, CONNECTORS=True, MAX_ION_CHARS=18
    ),
}
if PRESET not in PRESETS:
    raise ValueError(f"Unknown PRESET '{PRESET}'. Choose one of: {list(PRESETS)}")
globals().update(PRESETS[PRESET])
if ION_MODE not in ("ESI+","ESI-","EI"):  # guard if someone free-types
    ION_MODE = "ESI+"

# ── common masses
PROTON  = 1.007276466812
NH4     = 18.033823
Na      = 22.989218
K       = 38.963158
Cl      = 34.969402
Br      = 78.918885
ACN     = 41.026549
MeOH    = 32.026215
iPrOH   = 60.057515
DMSO    = 78.013940
Formate = 44.998201
Acetate = 59.013851
NO3     = 61.987819
H2O     = 18.010565

# fragment-adducts (for fragments only)
ADDUCT_MASSES = {
    "H+": PROTON, "NH4+": NH4, "Na+": Na, "K+": K, "[M]•+": 0.0,
    "H-": -PROTON, "Cl-": Cl, "CH3COO-": Acetate, "HCOO-": Formate, "NO3-": NO3
}
ADDUCT_WEIGHTS = {"H+":1.0,"NH4+":0.6,"Na+":0.4,"K+":0.25,"H-":1.0,"Cl-":0.4,
                  "CH3COO-":0.3,"HCOO-":0.35,"NO3-":0.2,"[M]•+":1.0}
ALPHA = 0.6

# molecular adducts list: (name, shift, charge z, prob%, multM)
ADDUCT_CATALOG = {
    "ESI+": [
        ("[M+H]+",          PROTON,                    +1, 62.6, 1),
        ("[M+NH4]+",        NH4,                       +1, 14.4, 1),
        ("[M+Na]+",         Na,                        +1,  8.8, 1),
        ("[M+K]+",          K,                         +1,  3.2, 1),
        ("[M+CH3OH+H]+",    MeOH + PROTON,             +1,  3.1, 1),
        ("[M+ACN+H]+",      ACN  + PROTON,             +1,  3.5, 1),
        ("[M+IsoProp+H]+",  iPrOH + PROTON,            +1,  1.4, 1),
        ("[M+DMSO+H]+",     DMSO + PROTON,             +1,  0.7, 1),
        ("[M+ACN+Na]+",     ACN  + Na,                 +1,  2.0, 1),
        ("[M+CH3OH+Na]+",   MeOH + Na,                 +1,  1.0, 1),
        ("[M+2K-H]+",       2*K - PROTON,              +1,  0.3, 1),
        ("[M+2H]2+",        2*PROTON,                  +2,  2.0, 1),
        ("[M+H+NH4]2+",     PROTON + NH4,              +2,  0.9, 1),
        ("[M+H+Na]2+",      PROTON + Na,               +2,  0.7, 1),
        ("[M+H+K]2+",       PROTON + K,                +2,  0.4, 1),
        ("[M+2Na]2+",       2*Na,                      +2,  0.4, 1),
        ("[M+ACN+2H]2+",    ACN + 2*PROTON,            +2,  0.5, 1),
        ("[M+2ACN+2H]2+",   2*ACN + 2*PROTON,          +2,  0.3, 1),
        ("[M+3H]3+",        3*PROTON,                  +3,  0.33,1),
        ("[M+2H+Na]3+",     2*PROTON + Na,             +3,  0.30,1),
        ("[2M+H]+",         PROTON,                    +1,  2.0,  2),
        ("[2M+Na]+",        Na,                        +1,  1.5,  2),
        ("[2M+K]+",         K,                         +1,  0.7,  2),
        ("[2M+ACN+H]+",     ACN + PROTON,              +1,  0.5,  2),
        ("[2M+ACN+Na]+",    ACN + Na,                  +1,  0.4,  2),
    ],
    "ESI-": [
        ("[M-H]-",          -PROTON,                   -1, 50.0, 1),
        ("[M-2H]2-",        -2*PROTON,                 -2,  2.0, 1),
        ("[M-3H]3-",        -3*PROTON,                 -3,  0.7, 1),
        ("[M-H2O-H]-",      -(H2O+PROTON),             -1,  5.0, 1),
        ("[M+Na-2H]-",      Na - 2*PROTON,             -1,  4.0, 1),
        ("[M+Cl]-",         Cl,                        -1,  8.0, 1),
        ("[M+K-2H]-",       K - 2*PROTON,              -1,  2.0, 1),
        ("[M+FA-H]-",       Formate,                   -1, 10.0, 1),
        ("[M+Hac-H]-",      Acetate,                   -1,  6.0,  1),
        ("[M+Br]-",         Br,                        -1,  3.0,  1),
        ("[M+TFA-H]-",      112.985586,                -1,  1.5,  1),
        ("[2M-H]-",         -PROTON,                   -1,  3.0,  2),
        ("[2M+FA-H]-",      Formate,                   -1,  2.0,  2),
        ("[2M+Hac-H]-",     Acetate,                   -1,  1.0,  2),
        ("[3M-H]-",         -PROTON,                   -1,  0.5,  3),
    ],
    "EI": [("[M]•+", 0.0, +1, 100.0, 1)],
}

def _frag_weight(frag, adduct):
    mass = rdMD.CalcExactMolWt(frag)
    hetero = sum(1 for a in frag.GetAtoms() if a.GetAtomicNum() not in (1,6))
    return (hetero+1) * mass**(-ALPHA) * ADDUCT_WEIGHTS.get(adduct, 0.2)

def _molecular_adducts(mass_M, mode):
    out = []
    for name, shift, z, prob, mMult in ADDUCT_CATALOG.get(mode, []):
        z_abs = abs(int(z)) if int(z) != 0 else 1
        mz = (mMult*mass_M + shift) / z_abs
        out.append((name, round(mz, 4), float(prob)))
    return out

def simulate_spectrum(smiles, mode="ESI+"):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None: raise ValueError("Invalid SMILES.")
    pmass = rdMD.CalcExactMolWt(mol)

    if mode == "ESI+":
        frag_adducts = ("H+","NH4+","Na+","K+")
    elif mode == "ESI-":
        frag_adducts = ("H-","Cl-","CH3COO-","HCOO-","NO3-")
    else:
        frag_adducts = ("[M]•+",)

    from collections import defaultdict, Counter
    label_map = defaultdict(list)
    repr_frag = {}
    records   = []

    # 1) FRAGMENTS
    w_frag = Counter()
    for b in mol.GetBonds():
        if b.IsInRing() or b.GetBondType()!=Chem.BondType.SINGLE:
            continue
        split = Chem.FragmentOnBonds(mol,[b.GetIdx()], addDummies=False)
        for frag in Chem.GetMolFrags(split, asMols=True, sanitizeFrags=True):
            if frag.GetNumHeavyAtoms()<2:
                continue
            mass = rdMD.CalcExactMolWt(frag)
            formula = CalcMolFormula(frag)
            for ad in frag_adducts:
                mz = round(mass + ADDUCT_MASSES[ad], 4)
                w  = _frag_weight(frag, ad)
                w_frag[mz] += w
                lab = f"{formula}.{ad}"
                label_map[mz].append(lab)
                records.append({"mz":mz,"mol":frag,"label":lab,"w":w})
                if (mz not in repr_frag) or w>repr_frag[mz][2]:
                    repr_frag[mz]=(frag,lab,w)

    if w_frag:
        fmax = max(w_frag.values())
        scale = FRAG_GROUP_MAX / fmax if fmax > 0 else 1.0
        for m in list(w_frag):
            w_frag[m] *= scale

    # 2) MOLECULAR ADDUCTS
    from collections import Counter
    w_add  = Counter()
    prob_by_mz = {}
    adduct_name_by_mz = {}
    for name, mz, prob in _molecular_adducts(pmass, mode):
        w = max(prob, 0.1)
        w_add[mz] += w
        label_map[mz].append(name)
        records.append({"mz":mz,"mol":mol,"label":name,"w":w})
        if (mz not in repr_frag) or w>repr_frag[mz][2]:
            repr_frag[mz]=(mol,name,w)
        prob_by_mz[mz] = prob
        adduct_name_by_mz[mz] = name

    if w_add:
        amax = max(w_add.values())
        scale = ADDUCT_GROUP_MAX / amax if amax > 0 else 1.0
        for m in list(w_add):
            w_add[m] *= scale

    # 3) COMBINE + gamma compression + floor
    combined = Counter(); combined.update(w_frag); combined.update(w_add)
    vals_combined = list(combined.values())
    base_lin = max(vals_combined) if vals_combined else 1e-12
    peaks = {}
    for m, w in combined.items():
        ri = 100.0 * (w / base_lin) ** INTENSITY_GAMMA
        if 0 < ri < MIN_VISIBLE_INT: ri = MIN_VISIBLE_INT
        peaks[m] = int(round(ri))

    ion_labels = {m:", ".join(sorted(set(v))) for m,v in label_map.items()}
    repr_map   = {m:{"mol":t[0], "label":t[1]} for m,t in repr_frag.items()}

    # 4) FIXED-norm colours for adduct labels
    cols_by_mz = {}
    if prob_by_mz:
        norm = mpl.colors.Normalize(vmin=PROB_COLOR_MIN, vmax=PROB_COLOR_MAX, clip=True)
        cmap = cm.get_cmap(COLOR_MAP_NAME)
        for mz, p in prob_by_mz.items():
            cols_by_mz[mz] = cmap(norm(p))
    return peaks, ion_labels, repr_map, records, cols_by_mz, prob_by_mz, adduct_name_by_mz

def _thumb_png_b64(mol, w=260, h=200):
    pil = Draw.MolToImage(mol, size=(w,h), kekulize=True)
    buf = io.BytesIO(); pil.save(buf, format="PNG")
    import base64
    return base64.b64encode(buf.getvalue()).decode("ascii")

def _rgba_to_hex(rgba):
    r,g,b,a = rgba
    return "#{:02x}{:02x}{:02x}".format(int(255*r), int(255*g), int(255*b))

# ── run
if not SMILES.strip():
    display(HTML("<b>Please enter a SMILES string.</b>"))
else:
    (peaks, ion_labels, repr_map, records,
     adduct_label_colours, adduct_probs, adduct_name_by_mz) = simulate_spectrum(SMILES, ION_MODE)

    mz = np.array(sorted(peaks), float)
    ints = np.array([peaks[m] for m in mz], float)

    fig, ax = plt.subplots(figsize=(FIG_W_IN, FIG_H_IN), dpi=FIG_DPI)
    ax.set_facecolor("white"); fig.patch.set_facecolor("white")
    ax.vlines(mz, 0, ints, lw=2, color="#1f77b4")
    ax.set_title(f"Simulated Mass Spectrum for {SMILES}  ({ION_MODE})", fontsize=PRESETS[PRESET]["TITLE_FONTSIZE"])
    ax.set_xlabel("m/z", fontsize=PRESETS[PRESET]["AXIS_LABEL_FONTSIZE"])
    ax.set_ylabel("Relative Intensity", fontsize=PRESETS[PRESET]["AXIS_LABEL_FONTSIZE"])
    ax.tick_params(labelsize=PRESETS[PRESET]["TICK_FONTSIZE"])
    ax.spines[["top","right"]].set_visible(False)
    ax.set_xlim(mz.min()-5, mz.max()+5); ax.set_ylim(0, max(ints)*1.25)

    # colourbar with fixed percentage scale
    if SHOW_COLORBAR:
        norm = mpl.colors.Normalize(vmin=PROB_COLOR_MIN, vmax=PROB_COLOR_MAX, clip=True)
        sm = mpl.cm.ScalarMappable(norm=norm, cmap=cm.get_cmap(COLOR_MAP_NAME)); sm.set_array([])
        cbar = fig.colorbar(sm, ax=ax, fraction=0.025, pad=0.02)
        cbar.set_label("Adduct probability (%)", fontsize=10)
        cbar.ax.tick_params(labelsize=9)

    # --- choose peaks to label (thinning)
    cands = []
    for m, y in zip(mz, ints):
        if peaks[float(m)] < MIN_VISIBLE_INT:
            continue
        ion = ion_labels.get(float(m), "")
        ion = ion.split(",")[0] if "," in ion else ion
        is_adduct = 1 if ion.startswith("[M") else 0
        cands.append((is_adduct, peaks[float(m)], m, y, ion))

    cands.sort(key=lambda t: (t[0], t[1], t[2]), reverse=True)
    chosen = []; used = []
    for _, _, m, y, ion in cands:
        if all(abs(m - uu) >= PRESETS[PRESET]["MIN_MZ_GAP"] for uu in used):
            chosen.append((m, y, ion)); used.append(m)
            if len(chosen) >= PRESETS[PRESET]["MAX_LABELS"]:
                break

    # --- place labels with *hard* constraints
    from matplotlib import patheffects as pe
    base_yoff = max(ints)*PRESETS[PRESET]["LABEL_Y_OFFSET_FRAC"]
    placed_x = []
    texts    = []
    lane_scale = [1.0 + 0.36*i for i in range(PRESETS[PRESET]["LABEL_LANES"])]
    all_sticks = np.array(mz, float)

    placed_meta = []  # [(priority_rank, text_obj)]
    for rank, (m, y, ion) in enumerate(sorted(chosen, key=lambda t: t[0])):
        ion_short = ion if len(ion) <= PRESETS[PRESET]["MAX_ION_CHARS"] else (ion[:PRESETS[PRESET]["MAX_ION_CHARS"]-1]+"…")
        txt = f"{ion_short}\n{m:.2f}" if LABEL_MODE=="ion+mz" else ion_short if LABEL_MODE=="ion" else f"{m:.2f}"
        color_lbl = adduct_label_colours.get(float(m), "black")

        placed = False
        for lane_idx in range(PRESETS[PRESET]["LABEL_LANES"]):
            yoff = base_yoff * lane_scale[lane_idx]
            for k in range(-PRESETS[PRESET]["MAX_DODGE_STEPS"], PRESETS[PRESET]["MAX_DODGE_STEPS"]+1):
                x_try = m + k*PRESETS[PRESET]["X_DODGE_STEP"]
                if np.min(np.abs(all_sticks - x_try)) < STICK_CLEAR_DX:
                    continue
                if placed_x and min(abs(x_try - px) for px in placed_x) < max(PRESETS[PRESET]["MIN_LABEL_X_SEP"], TEXT_CLEAR_DX):
                    continue
                t = ax.text(x_try, y+yoff, txt, ha="center", va="bottom", rotation=90,
                            fontsize=PRESETS[PRESET]["LABEL_FONTSIZE"], color=color_lbl, clip_on=False,
                            path_effects=[pe.withStroke(linewidth=2.2, foreground="white")])
                texts.append(t); placed_x.append(x_try)
                if PRESETS[PRESET]["CONNECTORS"]:
                    ax.plot([m, x_try], [y, y+yoff*0.88], color="0.45", lw=0.5)
                placed_meta.append((rank, t))
                placed = True
                break
            if placed: break
        # if not placed: skip (keeps figure clean)

    # --- gentle y-only adjustment, then hard pixel-space pruning of overlaps
    try:
        adjust_text(texts, only_move={"points":"y","texts":"y"},
                    autoalign="y", expand_points=(1.1,1.1),
                    arrowprops=dict(arrowstyle="-", color="0.45", lw=0.4))
    except Exception:
        pass

    # Pixel-space prune: keep higher-priority label if two boxes intersect
    fig.canvas.draw()  # ensure text BBoxes are computed
    def _box(t):
        bb = t.get_window_extent(fig.canvas.get_renderer()).expanded(1.02, 1.02)
        return bb
    def _intersects(a,b):
        return not (a.x1 < b.x0 or a.x0 > b.x1 or a.y1 < b.y0 or a.y0 > b.y1)

    # sort by priority (lower rank = higher priority), keep best
    placed_meta.sort(key=lambda x: x[0])
    kept = []
    kept_boxes = []
    for rank, t in placed_meta:
        bb = _box(t)
        if any(_intersects(bb, kb) for kb in kept_boxes):
            t.remove()  # drop the lower-priority overlapping label
        else:
            kept.append(t); kept_boxes.append(bb)

    # --- full-stick hover
    xs, ys, tooltips = [], [], []
    thumb_cache = {}
    for m, y in zip(mz, ints):
        ys_i = np.linspace(0, y, PRESETS[PRESET]["SAMPLES_PER_STICK"])
        xs_i = np.full_like(ys_i, m, dtype=float)
        xs.append(xs_i); ys.append(ys_i)
        info = repr_map.get(float(m), {}); mol = info.get("mol")
        label_txt = ion_labels.get(float(m), "").split(",")[0] or info.get("label")
        caption = f"{label_txt} · m/z={m:.4f}" if label_txt else f"m/z={m:.4f}"
        if mol is None:
            tip_html = f"<div class='ion-cap'>{caption}</div>"
        else:
            if float(m) not in thumb_cache:
                b64 = _thumb_png_b64(mol, 260, 200)
                thumb_cache[float(m)] = (
                    f"<div class='ion-tip'>"
                    f"  <img src='data:image/png;base64,{b64}' "
                    f"       style='width:260px;height:200px;display:block;margin:auto'/>"
                    f"  <div class='ion-cap'>{caption}</div>"
                    f"</div>"
                )
            tip_html = thumb_cache[float(m)]
        tooltips.extend([tip_html] * PRESETS[PRESET]["SAMPLES_PER_STICK"])

    xs = np.concatenate(xs); ys = np.concatenate(ys)
    hot = ax.scatter(xs, ys, s=120, alpha=0)

    css = f""".mpld3-tooltip{{background:#fff;border:1px solid #555;padding:8px;border-radius:8px;color:#000;}}
              .ion-tip{{filter:drop-shadow(0 1px 3px rgba(0,0,0,.25))}}
              .ion-cap{{font-family:monospace;margin-top:6px;text-align:center;color:#000;
                        font-size:{PRESETS[PRESET]['TOOLTIP_CAPTION_PX']}px;}}"""
    plugins.connect(fig, plugins.PointHTMLTooltip(hot, labels=tooltips, hoffset=12, voffset=12, css=css))

    # --- small legend of adducts
    if SHOW_ADDUCT_LIST and adduct_probs:
        items = []
        for m, p in adduct_probs.items():
            name = adduct_name_by_mz.get(m, f"m/z {m:.2f}")
            rgba = adduct_label_colours.get(m, (0,0,0,1))
            items.append((name, p, "#{:02x}{:02x}{:02x}".format(int(rgba[0]*255), int(rgba[1]*255), int(rgba[2]*255))))
        items.sort(key=lambda t: t[1], reverse=True)
        items = items[:ADDUCT_LEGEND_MAX]
        rows = []
        for name, p, hexcol in items:
            rows.append(
                f"<div style='display:flex;align-items:center;margin:2px 0;'>"
                f"<span style='display:inline-block;width:12px;height:12px;background:{hexcol};"
                f"border:1px solid #555;margin-right:6px;'></span>"
                f"<span style='font-family:monospace'>{name}</span>"
                f"<span style='margin-left:8px;color:#444;font-family:monospace'>({p:.1f}%)</span>"
                f"</div>"
            )
        legend_html = (
            "<div style='margin:.35rem 0 .2rem 0;font-weight:600'>Adducts present (fixed colour scale)</div>"
            + "".join(rows)
        )
    else:
        legend_html = ""

    fig_html = mpld3.fig_to_html(fig); plt.close(fig)
    wpx = int(PRESETS[PRESET]["FIG_W_IN"] * PRESETS[PRESET]["FIG_DPI"])
    display(HTML(
        "<div style='font-style:italic;margin:.25rem 0 .5rem 0'>"
        f"Mode: <b>{ION_MODE}</b> · Preset: <b>{PRESET}</b> — hover anywhere on a blue stick for the thumbnail. "
        f"Adduct colours use a fixed {PROB_COLOR_MIN:.0f}–{PROB_COLOR_MAX:.0f}% scale "
        f"(<span style='color:#b30000'>red</span> high → <span style='color:#2b83ba'>blue</span> low). "
        f"Fragment labels (formulas) are black (no probability data).</div>"
        f"<div style='width:100%; overflow-x:auto;'>"
        f"  <div style='width:{wpx}px; margin:0 auto;'>{fig_html}</div>"
        f"</div>"
        f"{legend_html}"
    ))

#@title Create and download a CSV report
import pandas as pd
from rdkit import Chem

# Extract data from the 'records' list
data = []
for record in records:
    mol = record['mol']
    smiles = Chem.MolToSmiles(mol) if mol else '' # Get SMILES, handle potential None
    peak_name = record['label']
    mz = record['mz']
    data.append([smiles, peak_name, mz])

# Create a pandas DataFrame
df = pd.DataFrame(data, columns=['SMILES', 'Peak Name', 'm/z'])

# Display the entire DataFrame as a string
print(df.to_string())

# Download the DataFrame as a CSV
from google.colab import files
df.to_csv('mass_spectrum_peaks.csv', index=False)
files.download('mass_spectrum_peaks.csv')